## Предисловие
Это руководство предполагает базовые знания как **[GreenSock Animation Platform](https://greensock.com/get-started-js/)** (GSAP), так и **[React](https://reactjs.org/)**, а также некоторые общие инструменты, используемые для разработки приложений React.

Поскольку **[GSAP](https://greensock.com/gsap)** становится де-факто стандартом для создания богатой анимации и пользовательского интерфейса в Интернете, разработчики должны научиться интегрировать его с другими инструментами, такими как React, который стал популярен, потому что позволяет разработчикам писать свои приложения в модульном, декларативном и многократно используемом виде. Как модератор на **[форумах GreenSock](https://greensock.com/forums/)**, я заметил, что есть несколько общих препятствий для беспрепятственной совместной работы этих двух элементов, например ссылка на элемент DOM соответственно, делая что-то **The React Way** и т. д., поэтому я пишу эту статью.

Мы не будем углубляться в то, как должно быть структурировано приложение React, поскольку мы сосредоточены на использовании GSAP, но методы, используемые в этом руководстве, соответствуют официальным рекомендациям и были проверены разработчиками инструмента React Transition Group. Мы начнем с простого, а ближе к концу будем усложнять.

## Как работает GSAP
GSAP в основном обновляет числовые свойства объекта много раз в секунду, что создает иллюзию анимации. Для элементов DOM GSAP обновляет свойства встроенного стиля.

```js
const myElement = document.getElementById("my-element");
TweenLite.to(myElement, 1, {width: 100, backgroundColor: "red"});
```

Как видите, это означает, что нам нужен доступ к фактическому узлу DOM, отображаемому в документе, чтобы передать его методу `TweenLite.to()`.

## Как работает React
Объяснение того, как работает React, выходит за рамки этой статьи, но давайте сосредоточимся на том, как React получает **[JSX](https://reactjs.org/docs/introduction-jsx.html)** код, который мы пишем и помещаем в DOM.

```js
<div className="my-class">
  Здесь ваш контент
</div>
```

В React мы обычно не передаем элементу атрибут id, потому что мы используем декларативный способ доступа к методам, экземплярам, свойствам и состоянию. Именно через состояние компонента (или приложения) мы можем изменить способ представления вещей в DOM. Прямых манипуляций с DOM нет, поэтому обычно нет необходимости обращаться к DOM.

Команда React дала разработчикам способы доступа к узлам DOM, когда это необходимо, и API немного изменился с годами по мере развития React. В настоящее время (сентябрь 2018 г.) последняя версия React (16.4.2) позволяет разработчикам использовать ссылки для доступа к узлам DOM. В этом руководстве мы в основном будем использовать **[Callback Refs](https://reactjs.org/docs/refs-and-the-dom.html#callback-refs)** для создания ссылки на узел DOM. а затем передать его в анимацию GSAP, потому что GSAP гораздо быстрее напрямую манипулирует свойствами, а не направляет их через конечный автомат React.

## Создание нашей первой анимации

Мы будем использовать **ref** для доступа к узлу DOM и **[componentDidMount()](https://reactjs.org/docs/react-component.html#componentdidmount)** метод жизненного цикла компонента. для создания нашей первой анимации, потому что это гарантирует, что узел был добавлен в дерево DOM и готов к передаче в анимацию GSAP.

```js
class MyComponent extends Component {
  constructor(props){
    super(props);
    // ссылка на узел DOM
    this.myElement = null;
    // ссылка на экземпляр GSAP
    this.myTween = null;
  }
  
  componentDidMount(){
    // используйте ссылку на узел для создания экземпляра GSAP
    this.myTween = TweenLite.to(this.myElement, 1, {x: 100, y: 100});
  }

  render(){
    return <div ref={div => this.myElement = div}>
    </div>;
  }
}
```
Не так уж и сложно, правда? Давайте рассмотрим код, чтобы понять, что происходит.
Сначала, когда мы создаем экземпляр этого класса, к нему добавляются два свойства: `myElement` и `myTween`, но оба они равны нулю. Зачем? Поскольку на этом этапе узел не был добавлен в дерево DOM, и если мы попытаемся передать этот узел в анимацию GSAP, мы получим ошибку, указывающую, что GSAP не может создать промежуточную цель `null`.

После инициализации нового экземпляра запускается метод **[render()](https://reactjs.org/docs/react-component.html#render)**. В методе рендеринга мы используем атрибут **ref**, который, по сути, представляет собой функцию с единственным параметром - узел DOM, добавляемый в дерево DOM. На этом этапе мы обновляем ссылку на узел DOM, созданный в конструкторе класса. После этого эта ссылка больше не является `null` и может использоваться в любом месте нашего компонента.

Наконец, запускается метод **[componentDidMount()](https://reactjs.org/docs/react-component.html#componentdidmount)** и обновляет ссылку на myTween с помощью **[TweenLite](https://greensock.com/docs/TweenLite)** tween, чья `target` является внутренней ссылкой на узел DOM, который должен анимироваться. Просто, элегантно и очень похоже на React от нас!

Стоит упомянуть, что мы могли бы создать **анимацию с одним запуском**, не создавая ссылку на анимацию TweenLite в методе конструктора. Мы могли бы просто создать анимацию движения в методе `componentDidMount`, и она сразу же запустилась бы, например:

```js
componentDidMount(){
  TweenLite.to(this.myElement, 1, {x: 100, y: 100});
}
```

Основное преимущество хранения анимации движения TweenLite в качестве ссылки в компоненте заключается в том, что этот шаблон позволяет нам использовать любой из методов, которые GSAP предлагает, например: [play()](https://greensock.com/docs/TweenMax/play()), [pause()](https://greensock.com/docs/TweenMax/pause()), [reverse()](https://greensock.com/docs/TweenMax/reverse()), [restart()](https://greensock.com/docs/TweenMax/restart()), [seek()](https://greensock.com/docs/TweenMax/seek()), изменить скорость ([timeScale](https://greensock.com/docs/TweenMax/timeScale())), и т.д., чтобы получить полный контроль над анимацией. Также этот подход позволяет нам создавать любую анимацию GSAP ([TweenLite](https://greensock.com/docs/TweenLite), [TweenMax](https://greensock.com/docs/TweenMax), [TimelineLite](https://greensock.com/docs/TimelineLite), и т. д.) в конструкторе. Например, мы могли бы использовать временную шкалу для создания сложной анимации:

```js
constructor(props){
  super(props);
  this.myElement = null;
  this.myTween = TimelineLite({paused: true});
}

componentDidMount(){
  this.myTween
    .to(this.myElement, 0.5, {x: 100})
    .to(this.myElement, 0.5, {y: 100, rotation: 180})
    .play();
}
```

При таком подходе мы создаем приостановленную временную шкалу в конструкторе и добавляем отдельные анимации движения, используя сокращенные методы. Поскольку временная шкала изначально была приостановлена, мы воспроизводим ее после добавления к ней всех подростков. Мы также можем оставить его приостановленным и управлять им где-нибудь в другом месте нашего приложения. Следующий пример демонстрирует эту технику:

#### SIMPLE TWEEN DEMO
[https://stackblitz.com/edit/gsap-react-simple-tween](https://stackblitz.com/edit/gsap-react-simple-tween)

## Анимация группы элементов
Одним из преимуществ использования React является то, что мы можем добавлять группу элементов с помощью метода `array.map()`, что сокращает объем HTML-кода, который мы должны написать. Это также может помочь нам при создании анимации для всех этих элементов. Предположим, вы хотите поэтапно анимировать группу элементов на экране. Это просто:

```js
constructor(props){
  super(props);
  this.myTween = new TimelineLite({paused: true});
  this.myElements = [];
}

componentDidMount(){
  this.myTween.staggerTo(this.myElements, 0.5, {y: 0, autoAlpha: 1}, 0.1);
}

render(){
  return <div>
    <ul>
      {elementsArray.map((element) => <li
        key={element.id}
        ref={li => this.myElements[index] = li}
      >
        {element.name}
      </li>)}
    </ul>
  </div>;
}
```
Это выглядит немного сложнее, но мы используем один и тот же шаблон для доступа к каждому узлу DOM. Единственное отличие состоит в том, что вместо использования одной ссылки для каждого элемента мы добавляем каждый элемент в массив. В методе **[componentDidMount()](https://reactjs.org/docs/react-component.html#componentdidmount)** мы используем **[TimelineLite.staggerTo()](https://greensock.com/docs/TimelineLite/staggerTo())**, а GSAP творит чудеса для создания смещенной анимации!

#### MULTIPLE ELEMENTS DEMO
[https://stackblitz.com/edit/gsap-react-multiple-elements](https://stackblitz.com/edit/gsap-react-multiple-elements)

## Создание сложной последовательности

Мы не всегда получаем все элементы в массиве, поэтому иногда нам может потребоваться создать сложную анимацию с использованием разных элементов. Как и в первом примере, мы сохраняем ссылку в конструкторе для каждого элемента и создаем нашу временную шкалу в **[componentDidMount()](https://reactjs.org/docs/react-component.html#componentdidmount)** метод:

#### TIMELINE SEQUENCE DEMO
[https://stackblitz.com/edit/gsap-react-timeline-sequence](https://stackblitz.com/edit/gsap-react-timeline-sequence)

Обратите внимание, как в этом примере мы используем комбинацию методов. Большинство элементов хранятся как свойство экземпляра с использованием this.element = null, но мы также добавляем группу элементов с помощью array.map (). Вместо использования обратного вызова `map ()` для создания анимаций на временной шкале (что вполне возможно) мы добавляем их в массив, который передается в **[staggerFrom()](https://greensock.com/docs/TimelineLite/staggerToFrom)** для создания эффекта колебания.

## Анимация через состояние

Наиболее часто используемый шаблон для обновления приложения React - это изменение состояния его компонентов. 
Таким образом, легко контролировать, когда и как элементы анимируются в зависимости от состояния приложения. Прослушивать изменения состояния и управлять анимацией GSAP в зависимости от состояния не очень сложно, используя **[componentDidUpdate()](https://reactjs.org/docs/react-component.html#componentdidupdate)** метод жизненного цикла. Обычно мы сравниваем значение свойства состояния до и после обновления и соответственно управляем анимацией.

```js
componentDidUpdate(prevProps, prevState) {
  if (prevState.play !== this.state.play) {
    this.myTween.play();
  }
}
```

#### CONTROL THROUGH STATE DEMO
[https://stackblitz.com/edit/gsap-react-state-control](https://stackblitz.com/edit/gsap-react-state-control)

В этом примере мы сравниваем значения различных свойств состояния (по одному для каждого метода управления, реализованного в компоненте), чтобы управлять анимацией по мере обновления этих значений. Важно отметить, что этот пример немного запутан для выполнения чего-то, что может быть достигнуто путем вызова метода непосредственно в обработчике событий (например, `onClick`). Основная идея - показать, как правильно управлять вещами через государство.

Более чистый и простой способ управлять анимацией - передать **[prop](https://reactjs.org/docs/jsx-in-depth.html#props-in-jsx)** из родительского компонента или через хранилище состояний приложений, такое как Redux или MobX. Эти модальные образцы делают именно это:

```js
// parent component
<ModalComponent
  visible={this.state.modalVisible}
  close={this.setModalVisible.bind(null, false)}
/>

// ModalComponent
constructor(props){
  super(props);
  this.modalTween = new TimelineLite({ paused: true });
}
componentDidMount() {
  this.modalTween
    .set(this.modalWrap, { autoAlpha: 1 })
    .to(this.modalDialog, 0.25, { y: 50 }, 0)
    .reversed(true)
    .paused(false);
}
componentDidUpdate(){
  this.modalTween.reversed(!this.props.visible);
}
```

Как видите, модальная анимация управляется обновлением свойства `visible`, переданного его родительским элементом, а также методом *close*, переданным как свойство. Этот код намного проще и снижает вероятность ошибки.

#### STATE MODAL DEMO
[https://stackblitz.com/edit/gsap-react-state-modal](https://stackblitz.com/edit/gsap-react-state-modal)

## Использование React Transition Group
**[React Transition Group](https://reactcommunity.org/react-transition-group/)**(RTG) - отличный инструмент, который обеспечивает другой уровень контроля при анимации элемента в приложении React. Это называется способностью монтировать и демонтировать либо анимируемый элемент, либо весь компонент. Это может показаться не таким уж большим при анимации одного изображения или div, но в некоторых случаях это может означать значительное повышение производительности нашего приложения.

#### SIMPLE TRANSITION DEMO
[https://stackblitz.com/edit/gsap-react-simple-transition-group](https://stackblitz.com/edit/gsap-react-simple-transition-group)

В этом примере компонент **[<Transition>](https://reactcommunity.org/react-transition-group/transition)** обертывает элемент, который мы хотим анимировать. Этот элемент остается отключенным, пока его свойство `show` имеет значение false. Когда значение изменяется на `true`, он монтируется, а затем начинается анимация. Затем, когда свойство снова устанавливается на `false`, запускается другая анимация, и когда она завершается, она отключается. Мы также можем использовать компонент `<Transition>` для обертывания всего компонента.

RTG также предоставляет компонент **[<TransitionGroup>](https://reactcommunity.org/react-transition-group/)**, который позволяет нам аналогичным образом управлять группой компонентов `<Transition>` один компонент `<Transition>` позволяет управлять подключением и отключением компонента. Это хорошая альтернатива для анимации динамических списков, в которые можно добавлять и/или удалять элементы, или списков на основе фильтрации данных.

#### TRANSITION GROUP DEMO
[https://stackblitz.com/edit/gsap-react-transition-group-list](https://stackblitz.com/edit/gsap-react-transition-group-list)

```js
<Transition
  timeout={1000}
  mountOnEnter
  unmountOnExit
  in={show}
  addEndListener={(node, done) => {
    TweenLite.to(node, 0.35, {
      y: 0,
      autoAlpha: show ? 1 : 0,
      onComplete: done,
      delay: !show ? 0 : card.init ? props.index * 0.15 : 0
    });
  }}
>
```
В этом примере мы используем обратный вызов **[addEndListener()](https://reactcommunity.org/react-transition-group/transition#Transition-prop-addEndListener)** из компонента `<Transition>`. Это дает нам два параметра: элемент `node`, добавляемый в дерево DOM, и обратный вызов `done`, который позволяет контролировать внутреннее состояние компонента `<Transition>`, когда элемент монтируется и отключается.

Вся анимация управляется свойством `in`, которое запускает `addEndListener()` и, в конечном итоге, анимацию. Вы можете заметить, что мы не создаем две разные анимации для состояния входа/выхода компонента. Мы создаем единую анимацию, которая использует тот же узел DOM и те же свойства. Таким образом, менеджер перезаписи GSAP уничтожает любую существующую анимацию, влияющую на один и тот же элемент и свойства, обеспечивая плавный переход между анимациями входа и выхода.

Наконец, использование RTG позволяет нам создать более детализированный код, поскольку мы можем использовать все обратные вызовы событий, предоставляемые GSAP (`onStart`, `onUpdate`, `onComplete`, `onReverse`, `onReverseComplete`) для запуска всех код, который мы хотим, перед вызовом обратного вызова `done` (чрезвычайно важно для уведомления о завершении анимации).

## Анимация изменений маршрута
Маршрутизация - один из наиболее распространенных сценариев в приложении React. Изменения маршрута в приложении React означают, что отображается совершенно другое представление в зависимости от пути в адресной строке браузера, который является наиболее распространенным шаблоном для отображения совершенно другого компонента при изменении маршрута. Очевидно, что анимация этих изменений придает нашим приложениям React очень профессиональный вид. Отображение нового компонента на основе изменения маршрута означает, что компонент предыдущего маршрута отключен, а компонент для следующего маршрута смонтирован. Мы уже рассмотрели анимацию анимации компонентов, привязанных к монтированию/размонтированию с использованием компонента `<Transition>` из RTG, так что это очень хороший вариант для анимации изменений маршрута.

```js
<BrowserRouter>
  <div>
    <Route path="/" exact>
      { ({ match }) =>  <Home show={match !== null} /> }
    </Route>
    <Route path="/services">
      { ({ match }) => <Services show={match !== null} /> }
    </Route>
    <Route path="/contact">
      { ({ match }) => <Contact show={match !== null} /> }
    </Route>
  </div>
</BrowserRouter>
```
Этот основной компонент использует React Router **[<BrowserRouter>](https://reacttraining.com/react-router/web/api/BrowserRouter)** и **[<Route>](https://reacttraining.com/react-router/web/api/Route)** и проверяет объект `match`, переданный в качестве опоры каждому компоненту `<Route>`, возвращая компонент, который должен отображаться для каждого URL. Также мы передаем свойство `show` каждому компоненту точно так же, как в примере **transition**.

```js
<Transition
  unmountOnExit
  in={props.show}
  timeout={1000}
  onEnter={node => TweenLite.set(node, startState)}
  addEndListener={ (node, done) => {
    TweenLite.to(node, 0.5, {
      autoAlpha: props.show ? 1 : 0,
      y: props.show ? 0 : 50,
      onComplete: done
    });
  }}
>
```

Как видите, код в основном тот же, что и для анимации отдельного компонента; Единственная разница в том, что теперь у нас есть две анимации, которые происходят в разных компонентах одновременно.

#### ROUTE ANIMATION DEMO
[https://stackblitz.com/edit/gsap-react-route-animation](https://stackblitz.com/edit/gsap-react-route-animation)

Стоит отметить, что анимации, используемые в этом примере, довольно просты, но вы можете использовать любой тип анимации, даже [сложные, вложенные анимации](https://css-tricks.com/writing-smarter-animation-code/).

Как вы видите, использование [GSAP](https://greensock.com/gsap) и [React](https://reactjs.org/) прекрасно сочетается друг с другом. 
Со всеми [инструментами и плагинами](https://greensock.com/plugins/?product_id=4921) GSAP может предложить безграничные возможности для создания убедительных и потрясающих приложений React!

## FAQ

1. Что это за «виртуальный DOM», о котором так много говорят, когда речь идет о React Apps ?. Может ли GSAP работать с этим виртуальным домом?

   **A** Виртуальная модель DOM - это то, что React использует для быстрого и эффективного обновления DOM. Чтобы узнать об этом больше, проверьте **[эту статью](https://medium.freecodecamp.org/a-quick-guide-to-learn-react-and-how-its-virtual-dom-works-c869d788cd44)** и **[React Docs](https://reactjs.org/docs/faq-internals.html)**. GSAP не может работать с виртуальной моделью DOM, потому что элементы виртуальной модели DOM сами по себе не являются узлами DOM.

2. Я часто читал о декларативном характере React. Влияет ли это на то, как мы используем GSAP в приложении React?

   **A** Да. React работает, обновляя визуализированный DOM за счет изменений в состоянии приложения, поэтому при создании анимации с использованием GSAP вместо прямого обращения к DOM, как в большинстве других случаев, нам нужно дождаться этих изменений в состоянии приложения и DOM для визуализации, чтобы использовать текущее представление состояния приложения и создать анимацию. Чтобы узнать больше о том, как работает декларативный и императивный код, прочтите **[эту статью](https://codeburst.io/declarative-vs-imperative-programming-a8a7c93d9ad2)**.

3. Во втором примере я вижу этот код в обратном вызове ref `ref={div => this.cards[i] = div}`. Почему используется индекс, а не просто вставка элемента в массив?

   **A** Причина этого в том, что каждый раз, когда компонент React повторно визуализируется, выполняется метод `render`, но исходный экземпляр остается неизменным. Массив, используемый для создания анимации, создается в конструкторе компонента. Анимация GSAP (TimelineLite) создается в ловушке `componentDidMount`. Эти два элемента создаются только один раз в жизненном цикле приложения, а метод рендеринга выполняется при каждом повторном рендеринге. Поэтому, если мы помещаем элементы в массив при каждом повторном рендеринге, даже если экземпляр Timeline не изменится, массив будет становиться все больше и больше каждый раз, когда компонент повторно рендерится. Это могло вызвать проблемы с памятью, особенно для больших коллекций.

4. В руководстве один из примеров запускает анимацию в зависимости от состояния компонента или приложения. Можно ли обновить состояние компонента/приложения с помощью GSAP?

   **A** Абсолютно! Все, что вам нужно сделать, это использовать одно из многих событий обратного вызова, которые может предложить GSAP. Единственная мера предосторожности - знать о бесконечных циклах. То есть, если анимация запускается в методе рендеринга компонента и обратный вызов этой анимации обновляет состояние компонента, то это запускает повторный рендеринг, который снова запускает анимацию. Вы можете проверить этот **[простой пример](https://stackblitz.com/edit/gsap-update-state)** того, как это можно сделать.

5. Можно ли инициировать изменение маршрута с помощью GSAP?

   **A** Это возможно с помощью API React Router. Хотя это не рекомендуется, потому что использование React Router API напрямую предотвратит запуск анимации изменения маршрута при использовании кнопок браузера *назад* и *вперёд*. Однако использование React Transition Group с GSAP действительно запускает анимацию изменения маршрута с помощью собственных методов навигации.

6. Могу ли я использовать другие плагины и инструменты GSAP в приложении React? В этом руководстве показаны только TweenMax, Timeline и CSS Plugin?

   **A** Да, любой инструмент или плагин GSAP, который вы хотите, можно использовать в приложении React. Просто следуйте тем же шаблонам и рекомендациям из этой статьи, и всё будет в порядке.

7. Я пробовал код из руководства и примеров, но он не работает. Что я могу сделать?

   **A** Зайдите на **[форумы GreenSock](https://greensock.com/forums/forum/11-gsap/)**, где на все ваши вопросы ответят как можно быстрее.

8. Я хочу внести свой вклад в это руководство или опубликовать проблему. Где я могу это сделать?

   **A** Несмотря на то, что это руководство было просмотрено экспертами GreenSock и React, возможно, что-то ускользнуло, или со временем и новыми версиями некоторые вещи следует или можно было бы сделать по-другому. В таких случаях перейдите в **[GitHub Repo](https://github.com/rhernandog/gsap-react-guide)** и сообщите о любых проблемах или создайте запрос на слияние с изменениями, которые, по вашему мнению, должны быть добавлены.

**Впервые в GSAP?** Check out the **[Getting Started Guide](https://greensock.com/get-started-js)**. Got questions? Head over to the **[GreenSock forums](https://greensock.com/forums/forum/11-gsap/)** where there's a fantastic community of animators.
Ознакомьтесь с **[Руководством по началу работы](https://greensock.com/get-started-js)**. Есть вопросы? Зайдите на **[форумы GreenSock](https://greensock.com/forums/forum/11-gsap/)**, где есть фантастическое сообщество аниматоров.

## Благодарности
Я хотел бы поблагодарить трех разработчиков, которые потратили время на свою работу и жизнь, чтобы просмотреть это руководство, а также примеры в нем. Я не смог бы сделать это без их помощи и ценной информации. Обязательно следуйте им:

- **Xiaoyan Wang**: A very talented React developer. While Xiaoyan doesn't have a very active social life (twitter, facebook, etc), you can follow what he does in **[GitHub](https://github.com/horizon-blue)**.

- **Jason Quense**: One of the maintainers of React Transition Group and part of the React Bootstrap Team. Jason also collaborates in many other React-related projects. Check Jason's **[GitHub profile](https://github.com/jquense)** for more info.


- **Matija Marohnić**: The most active contributor and maintainer of React Transition Group and Part of the Yeoman Team. Matija also contributes in a lot of React-related projects as well as many other open source software. Be sure to follow Matija in **[GitHub](https://github.com/silvenon)** and **[Twitter](https://twitter.com/silvenon)**.
